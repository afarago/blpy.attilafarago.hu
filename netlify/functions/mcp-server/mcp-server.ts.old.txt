// import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import {
    ErrorCode,
    McpError,
    ToolAnnotations // Import ToolAnnotations if you plan to use them
} from '@modelcontextprotocol/sdk/types.js';
import { z } from 'zod'; // Import zod for defining schemas
import { conversionService } from '../../shared/conversion-service';
import { fileService } from '../../shared/file-service';

// Assuming SAMPLE_FILES and getFileFromArgs are also in shared or can be imported
// For simplicity, I'm keeping them here, but consider moving them to a shared utility file.
const SAMPLE_FILES = [
    "demo_cityshaper_cranemission.lms",
    "demo_cityshaper_cranemission.llsp",
    "demo_cityshaper_cranemission.llsp3",
    "demo_cityshaper_cranemission.lmsp",
    "demo_cityshaper_cranemission.ev3",
    "demo_cityshaper_cranemission.rbf",
    "demo_cityshaper_cranemission_wedo2.proj"
];

async function getFileFromArgs(args: any) {
    if (args.file) {
        return await fileService.getFileFromSample(args.file, process.env.URL);
    } else if (args.file_content && args.file_name) {
        return fileService.getFileFromBase64(args.file_name, args.file_content);
    } else {
        throw new Error('Either file (sample) or file_content+file_name must be provided');
    }
}

export class BlocklyPyMcpServer {
    server: McpServer;

    constructor() {
        this.server = new McpServer(
            {
                name: 'blocklypy-mcp-server',
                version: '1.0.0',
                // You can add a description here too if you like
                // description: 'A server for converting LEGO block-based programs to Python and other formats.'
            },
            {
                capabilities: {
                    tools: {}, // Still declare tool capabilities here
                },
            }
        );

        this.setupTools(); // Renamed from setupToolHandlers for clarity
    }

    setupTools() {
        // Define common input schema properties for file handling
        const fileInputSchema = {
            file: z.enum(SAMPLE_FILES).optional().describe('Sample file to convert (use this OR file_content, not both)'),
            file_content: z.string().optional().describe('Base64 encoded file content to convert (use this OR file, not both)'),
            file_name: z.string().optional().describe('Original filename (required when using file_content)'),
        };

        // Define the oneOf condition for file or file_content/file_name
        const fileOneOfSchema = z.union([
            z.object({ file: z.string() }).strict(),
            z.object({ file_content: z.string(), file_name: z.string() }).strict()
        ]).describe('Either a sample file or base64 content with filename must be provided.');


        // Register convert_to_python tool
        this.server.tool(
            'convert_to_python',
            'Convert LEGO block-based program files to Python code using BlocklyPy',
            z.object({
                ...fileInputSchema,
                comments: z.boolean().default(true).describe('Include additional comments in the Python output')
            }).and(fileOneOfSchema), // Combine with the oneOf schema
            async (args) => {
                try {
                    const fileResult = await getFileFromArgs(args);
                    const config = {
                        ...fileResult,
                        additionalCommentsChecked: args.comments ?? true,
                    };
                    const result = await conversionService.convertToPython(config);
                    return {
                        content: [
                            {
                                type: 'text',
                                text: `Python code generated from ${fileResult.fileName}:\n\n${result.content}`
                            }
                        ]
                    };
                } catch (error) {
                    throw new McpError(
                        ErrorCode.InternalError,
                        `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`
                    );
                }
            }
        );

        // Register convert_to_plain_text tool
        this.server.tool(
            'convert_to_plain_text',
            'Convert LEGO block-based program files to plain text representation',
            z.object({
                ...fileInputSchema,
                comments: z.boolean().default(false).describe('Include additional comments in the output')
            }).and(fileOneOfSchema),
            async (args) => {
                try {
                    const fileResult = await getFileFromArgs(args);
                    const config = {
                        ...fileResult,
                        additionalCommentsChecked: args.comments ?? true,
                    };
                    const result = await conversionService.convertToPlain(config);
                    return {
                        content: [
                            {
                                type: 'text',
                                text: `Plain text representation of ${fileResult.fileName}:\n\n${result.content}`
                            }
                        ]
                    };
                } catch (error) {
                    throw new McpError(
                        ErrorCode.InternalError,
                        `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`
                    );
                }
            }
        );

        // Register generate_dependency_graph tool
        this.server.tool(
            'generate_dependency_graph',
            'Generate a dependency graph from LEGO block-based program files',
            z.object({
                ...fileInputSchema,
                format: z.enum(['svg', 'png', 'dot', 'txt']).default('svg').describe('Output format for the graph')
            }).and(fileOneOfSchema),
            async (args) => {
                try {
                    const fileResult = await getFileFromArgs(args);
                    const config = {
                        ...fileResult,
                        additionalCommentsChecked: args.comments ?? true,
                    };
                    const result = await conversionService.generateDependencyGraph(config, args.format || 'svg');
                    return {
                        content: [
                            {
                                type: 'text',
                                text: `Dependency graph for ${fileResult.fileName} (${args.format || 'svg'} format):\n\n${result.content}`
                            }
                        ]
                    };
                } catch (error) {
                    throw new McpError(
                        ErrorCode.InternalError,
                        `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`
                    );
                }
            }
        );

        // Register generate_preview tool
        this.server.tool(
            'generate_preview',
            'Generate a graphical preview of LEGO block-based program files',
            z.object({
                ...fileInputSchema,
                format: z.enum(['svg', 'png']).default('svg').describe('Output format for the preview')
            }).and(fileOneOfSchema),
            async (args) => {
                try {
                    const fileResult = await getFileFromArgs(args);
                    const config = {
                        ...fileResult,
                        additionalCommentsChecked: args.comments ?? true,
                    };
                    const result = await conversionService.generatePreview(config, args.format || 'svg');
                    return {
                        content: [
                            {
                                type: 'text',
                                text: `Graphical preview of ${fileResult.fileName} (${args.format || 'svg'} format):\n\n${result.content}`
                            }
                        ]
                    };
                } catch (error) {
                    throw new McpError(
                        ErrorCode.InternalError,
                        `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`
                    );
                }
            }
        );

        // Register get_raw_source tool
        this.server.tool(
            'get_raw_source',
            'Get the raw source content of LEGO block-based program files',
            z.object({
                ...fileInputSchema,
                level: z.number().optional().describe('Specifies the ev3 binary (rbf) source level')
            }).and(fileOneOfSchema),
            async (args) => {
                try {
                    const fileResult = await getFileFromArgs(args);
                    const config = {
                        ...fileResult,
                        rawlevel: args.level ?? 3,
                    };
                    const result = await conversionService.getRawSource(config);
                    return {
                        content: [
                            {
                                type: 'text',
                                text: `Raw source content of ${fileResult.fileName}:\n\n${result.content}`
                            }
                        ]
                    };
                } catch (error) {
                    throw new McpError(
                        ErrorCode.InternalError,
                        `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`
                    );
                }
            }
        );

        // Register list_sample_files tool
        this.server.tool(
            'list_sample_files',
            'List all available sample files that can be used for conversion',
            z.object({}), // No input arguments for this tool
            async () => {
                try {
                    return {
                        content: [
                            {
                                type: 'text',
                                text: `Available sample files:\n\n${SAMPLE_FILES.map(file => `• ${file}`).join('\n')}\n\nThese files can be used with the 'file' parameter in conversion tools.`
                            }
                        ]
                    };
                } catch (error) {
                    throw new McpError(
                        ErrorCode.InternalError,
                        `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`
                    );
                }
            }
        );
    }
}
